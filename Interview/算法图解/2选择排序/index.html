<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>

    /*
      选择排序

      首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
      再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
      重复第二步，直到所有元素均排序完毕。
    */

    var arr = [10, 3, 20, 8, 9, 4, 5];
    function selectionSotr(arr) {
      let minIndex, temp;
      const len = arr.length;

      for (let i = 0; i < len - 1; i++) {
        minIndex = i;
        for (let j = i + 1; j < len; j++) {
          if (arr[j] < arr[minIndex]) minIndex = j;
        }

        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
      }
      return arr;
    }

    console.log(selectionSotr(arr));

    /*
      冒泡排序

      比较相邻的元素。如果第一个比第二个大，就交换他们两个。
      对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
      针对所有的元素重复以上的步骤，除了最后一个。
      持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
    */

    function bubbleSort(arr) {

    }

    /*
      快速排序
      从数列中挑出一个元素，称为 "基准"（pivot）;
      重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
      递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；
    */
    
  </script>
</body>

</html>